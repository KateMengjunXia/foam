/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

CLASS({
  package: 'foam.util',
  name: 'JavaSource2',
  requires: [
    'foam.i18n.TranslationFormatStringParser',
    'foam.util.InlineTrait',
  ],

  methods: [
    function prepModel(model) {
      // Java doesn't support traits, so we'll copy traits into the model directly.
      model = this.InlineTrait.create().inlineTraits(model);

      var filter = function(m) {
        if ( m.labels && m.labels.indexOf('java') == -1 ) {
          return false;
        }
        return true;
      };

      model.properties = model.properties.filter(filter);
      model.methods = model.methods.filter(filter);
      model.listeners = model.listeners.filter(filter);

      return model;
    },
    function generate(model) {
      if ( model.javaSource ) {
        return model.javaSource();
      }
      return this.javaSource.call(this.prepModel(model), undefined, this);
    },
  ],

  templates: [
    function javaSource(_, util) {/*<%
var propertyMap = {}
var toPropertyMap = function(f) {
  propertyMap[f.name] = f;
}
this.properties.forEach(toPropertyMap);

var idName;
var modelProperties = [];
var overriddenProperties = [];
var runtimeProperties = this.getRuntimeProperties();
var parent = this.X.lookup(this.extends);
for ( var i = 0 ; i < runtimeProperties.length ; i++ ) {
  var prop = runtimeProperties[i];
  if (prop.name == 'id') { idName = prop.name; }
  if (prop.labels && (
    prop.labels.indexOf('compiletime') != -1 ||
    prop.labels.indexOf('java') == -1 ) ) { continue; }
  if (parent && parent.getProperty(prop.name)) {
    if (propertyMap[prop.name]) {
      overriddenProperties.push(prop);
    }
    continue;
  }
  modelProperties.push(prop)
}
var allProperties = modelProperties.concat(overriddenProperties);
if (!idName) {
  if (this.ids && this.ids.length) {
    idName = this.ids[0];
  } else if(allProperties.length) {
    idName = allProperties[0].name;
  }
} else {
  // Since there's already an ID property, we don't need to do any special
  // handling of ID so unset it.
  idName = undefined;
}
%>
// Generated by foam.util.JavaSource2.  DO NOT MODIFY BY HAND
<% if ( this.package ) { %>
package <%= this.package %>;
<% } %>

<% this.javaClassImports.forEach(function(i) { %>
import <%= i %>;
<% }); %>

public class <%= this.javaClassName %> extends <%= parent && parent.javaClassName || 'Object' %> {

<% for ( var i = 0, message; message = this.messages[i]; i++) { %>
  static String <%= message.name %> = "<%= message.value %>";
<% } %>

<% for (var i = 0, constant; constant = this.constants[i]; i++) { %>
  <% if (constant.javaValue && constant.javaType) { %>
  static <%= constant.javaType %> <%= constant.name %> = <%= constant.javaValue %>;
  <% } %>
<% } %>

<%
for ( var i = 0 ; i < allProperties.length ; i++ ) {
  var prop = allProperties[i];
  var override = overriddenProperties.indexOf(prop) != -1 ? 'override' : '';
  var name = prop.name;
  var constant = constantize(name);
  var type = prop.javaType;
  var propertyModel = prop.model_.id.split('.').pop();
  var propFactory = prop.javaFactory || prop.javaLazyFactory;
%>
  <% if (!override) { %>
  <%= type %> <%= name %>_;
  boolean <%= name %>Inited_ = false;
  <% } %>

  public <%= type %> get<%= name.capitalize() %>() {
  <% if (prop.javaGetter) { %>
    <%= TemplateUtil.lazyCompile(TemplateUtil.expandTemplate(prop, prop.javaGetter)).bind(prop)() %>
  <% } else { %>
    if (<%= name %>Inited_) {
      return <%= name %>_;
    }
    <% if (prop.javaDefaultValue) { %>
    return <%= prop.javaDefaultValue %>;
    <% } else if (propFactory) { %>
    set<%= name.capitalize() %>(_<%= name %>_factory());
    return <%= prop.name %>_;
    <% } else { %>
    return <%= prop.name %>_;
    <% } %>
  <% } %>
  }

  <% if (propFactory) { %>
  private <%= type %> _<%= name %>_factory() { <%= propFactory %> }
  <% } %>



  private <%= type %> <%= name %>_adapt_(Object oldValue, Object newValue) {
    <%= TemplateUtil.lazyCompile(TemplateUtil.expandTemplate(prop, prop.javaAdapt)).bind(prop)() %>
  }
  protected <%= type %> <%= name %>_adapt(Object oldValue, Object newValue) {
  <% if (override) { %>
    return super.<%= name %>_adapt(oldValue, <%= name %>_adapt_(oldValue, newValue));
  <% } else { %>
    return <%= name %>_adapt_(oldValue, newValue);
  <% } %>
  }

  private <%= type %> <%= name %>_preSet_(Object oldValue, <%= type %> newValue) {
    <%= TemplateUtil.lazyCompile(TemplateUtil.expandTemplate(prop, prop.javaPreSet)).bind(prop)() %>
  }
  protected <%= type %> <%= name %>_preSet(Object oldValue, <%= type %> newValue) {
  <% if (override) { %>
    return super.<%= name %>_preSet(oldValue, <%= name %>_preSet_(oldValue, newValue));
  <% } else { %>
    return <%= name %>_preSet_(oldValue, newValue);
  <% } %>
  }

  private void <%= name %>_postSet_(Object oldValue, <%= type %> newValue) {
    <%= TemplateUtil.lazyCompile(TemplateUtil.expandTemplate(prop, prop.javaPostSet)).bind(prop)() %>
  }
  protected void <%= name %>_postSet(Object oldValue, <%= type %> newValue) {
  <% if (override) { %>
    super.<%= name %>_postSet(oldValue, newValue);
  <% } %>
    <%= name %>_postSet_(oldValue, newValue);
  }

  public void set<%= name.capitalize() %>(<%= type %> value) {
    <%= type %> oldValue = <%= name %>_;
    <%= name %>_ = <%= name %>_preSet(oldValue, <%= name %>_adapt(oldValue, value));
    <%= name %>Inited_ = true;
    <%= name %>_postSet(oldValue, <%= name %>_);
  }
<% } %>

  // TODO(mcarcaso): Equals and fclone shouldn't need to be generated. We should
  // be able to walk the properties at runtime.
  public boolean equals(Object o) {
    if (!(o instanceof <%= this.javaClassName %>)) {
      return false;
    }
    <%= this.javaClassName %> castedO = (<%= this.javaClassName %>) o;
<%
var primitives = [
  'byte',
  'char',
  'short',
  'int',
  'long',
  'float',
  'double',
  'boolean',
];
%>
<% for (var i = 0, prop; prop = allProperties[i]; i++) { %>
  <% var get = 'get' + prop.name.capitalize() + '()'; %>
  <% if (primitives.indexOf(prop.javaType) == -1) { %>
    if (<%= get %> != null) {
      if (!<%= get %>.equals(castedO.<%= get %>)) return false;
    } else if (castedO.<%= get %> != null) {
      return false;
    }
  <% } else { %>
    if (<%= get %> != castedO.<%= get %>) return false;
  <% } %>
<% } %>
    return true;
  }

  public <%= this.javaClassName %> fclone() {
    <%= this.javaClassName %> c = new <%= this.javaClassName %>();
<% for (var i = 0, prop; prop = allProperties[i]; i++) { %>
    c.set<%= prop.name.capitalize() %>(get<%= prop.name.capitalize() %>());
<% } %>
    return c;
  }


<%
  function javaSource(f) {
    f.javaSource$f && f.javaSource$f.call(f, out, self);
  }

  this.methods.forEach(javaSource);
  this.listeners.forEach(javaSource);
  this.actions.forEach(javaSource);
%>

  <%= multiline(this.javaCode) %>
}
    */},
  ],
});
